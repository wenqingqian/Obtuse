\newpage
\thispagestyle{fancy}
\setcounter{page}{1}
\chapter{\tt C++}
\thispagestyle{fancy}
%------------------------------------------------------------------------------------------------%
%-------------------------------------Section basic------------------------------------%
%------------------------------------------------------------------------------------------------%
\section{\color{blue}{基础}}

\subsection{<===>\color{purple}{{\tt C}和{\tt C++}区别}}

\begin{enumerate}
	\item {\tt C}语言是{\tt C++}的子集, {\tt C++}可以很好兼容{\tt C}语言. 但是{\tt C++}又有很多新特性, 
			如引用、智能指针、{\tt auto}变量等
	\item {\tt C++}是面对对象的编程语言; {\tt C}语言是面对过程的编程语言
	\item {\tt C}语言有一些不安全的语言特性, 如指针使用的潜在危险、强制转换的不确定性、内存泄露等. 
			而{\tt C++}对此增加了不少新特性来改善安全性, 如{\tt const}常量、引用、{\tt cast}转换、智能指针、
			{\tt try—catch}等等
	\item {\tt C++}可复用性高, {\tt C++}引入了模板的概念, 后面在此基础上, 实现了方便开发的标准模板库{\tt STL}. 
			{\tt C++}的{\tt STL}库相对于{\tt C}语言的函数库更灵活、更通用
\end{enumerate}
\subsection{<===>\color{purple}{{\tt C++}从代码到可执行二进制文件的过程}}
\begin{enumerate}
	\item 预编译: 这个过程主要的处理操作如下
	\begin{enumerate}
		\item 将所有的{\tt \#define}删除, 并且展开所有的宏定义
		\item 处理所有的条件预编译指令, 如{\tt \#if、\#ifdef}
		\item 处理{\tt \#include}预编译指令, 将被包含的文件插入到该预编译指令的位置
		\item 过滤所有的注释
		\item 添加行号和文件名标识
	\end{enumerate}
	\item 编译: 这个过程主要的处理操作如下
	\begin{enumerate}
		\item 词法分析: 将源代码的字符序列分割成一系列的记号
		\item 语法分析: 对记号进行语法分析, 产生语法树
		\item 语义分析: 判断表达式是否有意义
		\item 代码优化
		\item 目标代码生成: 生成汇编代码
		\item 目标代码优化
	\end{enumerate}
	\item 汇编: 这个过程主要是将汇编代码转变成机器可以执行的指令
	\item 将不同的源文件产生的目标文件进行链接, 从而形成一个可以执行的程序
	\begin{itemize}
		\item 链接分为静态链接和动态链接
		\item 静态链接, 是在链接的时候就已经把要调用的函数或者过程链接到了生成的可执行文件中, 
				就算你在去把静态库删除也不会影响可执行程序的执行; 生成的静态链接库, {\tt Windows}下以{\tt .lib}为后缀, 
				{\tt Linux}下以{\tt .a}为后缀
		\item 而动态链接, 是在链接的时候没有把调用的函数代码链接进去, 而是在执行的过程中, 再去找要链接的函数, 
				生成的可执行文件中没有函数代码, 只包含函数的重定位信息, 所以当你删除动态库时, 可执行程序就不能运行
				生成的动态链接库, {\tt Windows}下以{\tt .dll}为后缀, {\tt Linux}下以{\tt .so}为后缀
	\end{itemize}
\end{enumerate}
\subsection{<===>\color{purple}{{\tt static}关键字}}
\begin{enumerate}
	\item 全局静态变量和局部静态变量: 初始化的静态变量会在数据段分配内存, 未初始化的静态变量会在{\tt BSS}段分配内存. 
			直到程序结束, 静态变量始终会维持前值. 只不过全局静态变量和局部静态变量的作用域不一样
	\item 静态函数: 静态函数只能在本源文件(该翻译单元)中使用
	\item 类中的静态成员变量: 静态数据成员, 隐藏在类作用域中的全局变量(可以通过类名({\tt Class::})或类对象访问). 
			类中的{\tt static}静态数据成员拥有一块单独的存储区, 而不管创建了多少个该类的对象. 
			所有这些对象的静态数据成员都共享这一块静态存储空间
	\item 类中的静态成员函数: 静态成员函数也是类的一部分, 而不是对象的一部分
		\\  只能访问静态数据成员: 
			当调用一个对象的非静态成员函数时, 系统会把该对象的起始地址赋给成员函数的this指针. 
			而静态成员函数不属于任何一个对象, 因此{\tt C++}规定\uline{静态成员函数没有{\tt this}指针}. 
			既然它没有指向某一对象, 也就无法对一个对象中的非静态成员进行访问
\end{enumerate}
\subsection{<===>\color{purple}{{\tt extern}关键字与链接性}}

在{\tt C++}中, 翻译单元由实现文件及直接或间接包含的所有标头组成

\input{tex_include/pic_tex_include/cpp_basic_extern_0.tex}

\noindent 每个翻译单元由编译器单独编译, 最终将得到的.o文件链接得到可执行文件. 如上图所示程序结构, 在链接时会出现如下问题:

假如在{\tt head.h}文件中定义一个外部链接性变量

\begin{lstlisting}[xleftmargin=2em]
#ifndef HEAD_H
#define HEAD_H
int i = 0;
#endif
\end{lstlisting}
那么在链接时就会出错, 原因是如上两个翻译单元相当于

\input{tex_include/pic_tex_include/cpp_basic_extern_1.tex}

在两个文件中都定义了具有外部链接性的变量i.

在一个作用域内, 变量能且只能被定义一次, 但是可以被多次声明({\tt one define rule})
\begin{paracol}{2}
	\begin{leftcolumn}
		\begin{lstlisting}[title=定义,xleftmargin=2em,xrightmargin=2em]
// 不能在局部作用域内使用
extern int v = 0; 
int v;
		\end{lstlisting}
	\end{leftcolumn}
	\begin{rightcolumn}
		\begin{lstlisting}[title=声明,xleftmargin=2em,xrightmargin=2em]
void func();
extern void func();
extern int v;
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}

如果需要在多个文件, 指个多翻译单元中使用同一变量, 就必须把定义与声明分离. 变量的定义只能出现在一个文件中, 而在其它用到该变量
	的文件中对其声明.

所以往往头文件中只放一些声明而在另外的文件中进行定义.

\begin{paracol}{2}
	\begin{leftcolumn}
		常见的内部链接类型
		\begin{enumerate}
			\item {\tt const}全局变量
			\item {\tt static}全局变量
			\item {\tt static}函数
			\item {\tt inline}\footnote[1]{{\tt inline} 现在表示在链接时遇到不同编译单元出现了相同签名的函数时只保留一份, 不在是內联的意思.}函数/变量\footnote[2]{{\tt inline variable is C++17 extension}}
			\item 类内定义的成员函数
			\item 类内定义的数据成员(即非静态数据成员)
		\end{enumerate}
	\end{leftcolumn}
	\begin{rightcolumn}
		常见的外部链接类型
		\begin{enumerate}
			\item 全局变量与函数(非{\tt const、static、inline})
			\item 类外定义的数据成员(即静态数据成员在类外的定义)
			\item 类外定义的成员函数
			\item {\tt extern const T v = INIT;}
		\end{enumerate}
	\end{rightcolumn}
\end{paracol}
其它可视为无链接

\vspace{1em}
所有文件中的外部链接性变量会传递给链接器得到一张导出符号表. 记录本编译单元定义, 并且可提供给其它单元
	使用的符号及在本单元对应的地址. 

所有文件中的声明会传递给链接器得到一张未解决符号表, 记录本编译单元有声明但不在本单元定义的符号及其对应的地址, 
	显然在导出符号表中不能存在相同的符号.

\noindent{\tt C11}标准关于{\tt static}和{\tt extern}的内容:
\begin{enumerate}
	\item 若在{\tt extern}声明标识符之前的可见范围内存在对该标识符的声明, 则该标识符的链接与先前声明相同. 
			若无先前声明, 或声明无链接, 则该标识符具有外部链接
	\item 如果在同一翻译单元内, 同一标识符同时出现内外部链接, 则行为未定义
\end{enumerate}
上述原文:

{\tt For an identifier declared with the storage-class specifier extern in a scope 
in which a prior declaration of that identifier is visible, if the prior 
declaration specifies internal or external linkage, the linkage of the 
identifier at the later declaration is the same as the linkage specified 
at the prior declaration. If no prior declaration is visible, or if the 
prior declaration specifies no linkage, then the identifier has external 
linkage.

If, within a translation unit, the same identifier appears with both internal 
and external linkage, the behavior is undefined.}
\subsection{<===>\color{purple}{指针与引用}}
\subsubsection{指针与引用的区别}
\begin{enumerate}
	\item 引用就是常量指针
	\item 引用必须初始化, 且不能改变指向
	\item 无法对引用进行取地址, 或者说只能取到引用指向的对象的地址
	\item 引用的解引用操作由编译器自动进行
\end{enumerate}
\subsubsection{\tt{void*}指针}
指针一般有三个含义
\begin{enumerate}
	\item 指明数据的位置, 体现在指针的值
	\item 表示数据的大小, 例如{\tt int}指针表示四个字节为一组的数据, 体现在指针的步长、自身的加减法计算
	\item 表示数据如何被解释, 例如{\tt float}和{\tt int}都是四字节, 但解释结果完全不同, 体现在指针解引用的结果
\end{enumerate}

{\tt void*} 指针为第一种, 只指明了数据的位置. 以{\tt void*}的视角来看内存空间也仅仅是内存空间, 没办法访问内存空间中所存的对象

对于{\tt void*}类型指针与其它类型指针的转换, {\tt C++}有如下两个规定
\begin{enumerate}
	\item 不允许从{\tt void*}类型到其它类型的隐式转换, 允许从其它类型到{\tt void*}类型的隐式转换, 常见于函数传参
	\item 字面量0可以隐式转换成任意类型的空指针常量
\end{enumerate}

\subsubsection{\tt{nullptr\quad <11>}}

在{\tt C}中, 常用{\tt NULL}来表示空指针
\begin{lstlisting}[xleftmargin=2em]
#define NULL ((void*)0)
\end{lstlisting}
然而在{\tt C++}中不允许从{\tt void*}隐式转换成其它类型的指针, 所以定义了一种新的指针类型, 指针空值类型{\tt std::nullptr\_t}
	, {\tt nullptr}是它的一个实例, 当对指针进行初始化时:
\begin{lstlisting}[xleftmargin=2em]
int *p = nullptr;
int *p = 0;
\end{lstlisting}
两者之间没有区别

\noindent 但在重载情况下:
\begin{lstlisting}[xleftmargin=2em]
void func(int n);
void func(int *p);
\end{lstlisting}
{\tt nullptr}会匹配第二个, 而0实际上两个都能匹配, 在本实验环境中, 会匹配第一项且没有二义性问题

\noindent 若再定义一个
\begin{lstlisting}[xleftmargin=2em]
void func(char *p);
\end{lstlisting}
则{\tt nullptr}会出现二义性错误

至于空指针具体指向哪个地址由编译器管理, 可能是内存中的0号地址, 即指针数据全是0, 也有可能不是

%Effective Modern C++ 第8款, 使用nullptr 而非0, NULL.\\

\subsubsection{野指针}

{\tt wild pointer}也叫悬挂指针, {\tt dangling pointer}

有三种情况会造成野指针:
\begin{enumerate}
	\item 指针未初始化
	\item 指针指向的对象生命周期结束, 如将一个函数体内的局部变量地址传递给外部指针
	\item 指针释放
\end{enumerate}

当指针被{\tt delete}之后, 指针值变为无效, 继续对该指针进行操作会出现{\tt heap use after free}错误.

事实上, 当一个指针被{\tt delete}之后, 指针指向的堆地址空间被释放, 随时可以被分配给其它对象, 但在不同的机器上会有不同的结果.

\noindent 几种特殊情况, 指{\tt delete}之后继续使用指针不报错的情况:
\begin{enumerate}
	\item 指针的数据, 即它指向的地址发生改变, 对它进行解引用会得到0
	\item 地址不改变, 解引用会得到0
	\item 地址不改变, 该内存地址的值也未被擦除, 解引用得到跟{\tt delete}之前一样的结果
\end{enumerate}

准确来讲, {\tt delete}的实际意义是将指针指向的内存空间释放, 以便能分配给其它对象, 但指针本身是否依旧指向那块内存, 
	那块内存的数据是否被擦除未定义

给野指针赋{\tt nullptr}初值避免麻烦

\subsubsection{指向引用的指针, 指向指针的引用}
对引用地址的获取行为会得到引用指向的对象的地址

测试程序见 \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/basic/pointer_1}{\tt cpp\_basic\_pointer\_1}

\input{tex_include/pic_tex_include/cpp_basic_pointer_0.tex}
\subsection{\color{purple}{{\tt const}关键字}}
\subsection{\color{purple}{{\tt malloc}和{\tt new}区别}}
%------------------------------------------------------------------------------------------------%
%-------------------------------------Section object-oriented---------------------------%
%------------------------------------------------------------------------------------------------%
\section{\color{blue}{面向对象}}

\subsection[多态的实现原理和应用场景]{\color{purple}{多态的实现原理和应用场景}}
%------------------------------------------------------------------------------------------------%
%-------------------------------------Section STL---------------------------------------%
%------------------------------------------------------------------------------------------------%
\section{\color{blue}{\tt STL}}

\subsection{\color{purple}{线程安全的实现及标准容器库的线程安全性}}
\subsection{\color{purple}{{\tt sort}算法是怎么实现的}}

%------------------------------------------------------------------------------------------------%
%-------------------------------------Section C++11------------------------------------%
\section{\color{blue}{\tt C++11}}

\subsection{<===>\color{purple}{\tt{decltype}和\tt{auto}}}

\columnratio{0.5}
\begin{paracol}{2}
	\begin{leftcolumn}
		\begin{lstlisting}[title=decltype,basicstyle=\small,columns=flexible,xleftmargin=2em,xrightmargin=2em]
int *r=0;
decltype (*r+0) a;//表达式结果为int, 因此a为int
decltype (r) a;//a是指针
decltype (*r) a = ini;//a是引用
decltype ((r)) a = ini;//a是指向指针的引用
decltype ((*r)) a = ini;//a是引用 
		\end{lstlisting}
		{\tt decltype((variable))}的结果永远是引用.
	\end{leftcolumn}
	\begin{rightcolumn}
		\uline{{\tt auto}一般会忽略顶层{\tt const}, 保留底层{\tt const}}, 引用本身就是一个顶层{\tt const}指针, 因此{\tt auto}类型推导不会直接得到引用类型
		\begin{lstlisting}[basicstyle=\small,columns=flexible,xleftmargin=2em,xrightmargin=2em]
const int i = 1; const int&r = i;
auto a = i;//a是int
auto a = &i;//a是const int*(底层const)
auto a = r;//a是int
auto &a = i;//a是左引用
auto &&a;(万能引用)
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}
\subsection{<===>\color{purple}{左右值}}
\subsubsection{左值与右值}
 \href{https://zhuanlan.zhihu.com/p/402251966}{原文}

左值是一个对象, 可以用\&取地址, 而右值更贴近“值”本身. 一般来说, 表达式结束后, 
	值是否有\uline{显式}的存储位置是左右值的区分(右值可以隐式存在内存中)

\columnratio{0.5}
\begin{paracol}{2}
	\begin{leftcolumn}
		左值:
		\begin{enumerate}
			\item 字符串字面量
			\item 内置的前{\tt ++}与前{\tt --}
			\item 右值引用类型变量
			\item 转型为左值引用的表达式
			\item *解引用的表达式
		\end{enumerate}
	\end{leftcolumn}
	\begin{rightcolumn}
		右值:
		\begin{enumerate}
			\item 非字符串的字面量以及枚举项
			\item 置的后{\tt++}与后{\tt- -}
			\item 内置的算术, 逻辑, 比较表达式
			\item 内置取地址表达式, {\tt this}指针
			\item 未命名的{\tt lambda}表达式
			\item 转型为非引用的表达式
			\item 转型为右值引用的表达式
		\end{enumerate}
	\end{rightcolumn}
\end{paracol}
\subsubsection{左值引用与右值引用}

左右值并不是{\tt C++11}才有的新概念, 而右值引用是{\tt C++11}为了处理
	无需深拷贝的资源转移型需求而引入

左右引用只能处理对应的左右值. 一个例外是{\tt const T\&}, 既可以引用左值, 也可以引用右值

\noindent 即可以写出这样的代码
\begin{lstlisting}[basicstyle=\small,columns=flexible,xleftmargin=16em,xrightmargin=16em]
const int& clr = 1; const int& clr2 = clr;
\end{lstlisting}

\vspace*{2em}
\columnratio{0.4}
\begin{paracol}{2}
	\begin{leftcolumn}
		对于右值来说, 不能真正取地址, 而引用实质就是操作地址指针, 因此理论上无法进行左引用. 对于左值来说, 
			可以显式转换成右值引用

		如右值例7, 转换为右值引用的表达式本身是一个右值, 但是通过右值引用绑定到的对象自身是一个左值, 即左值例3
	\end{leftcolumn}
	\begin{rightcolumn}
		\begin{lstlisting}[basicstyle=\small,columns=flexible,xleftmargin=5em,xrightmargin=5em]
//可以将左值转为右值, 再进行右引用
Test t(1);
// 使用std::move转为右值引用
Test&& t1 = std::move(t);
// 使用static_cast转为右值引用
Test&& t2 = static_cast<Test&&>(t);
// 使用C风格强转为右值引用
Test&& t3 = (Test&&)t;
// 使用std::forwad<T&&>为右值引用
Test&& t4 = std::forward<T&&>(t);
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}
\subsection{<===>\color{purple}{移动语义与完美转发}}
\subsubsection{浅拷贝与深拷贝}
\columnratio{0.5}
\begin{paracol}{2}
	
	\begin{leftcolumn}
	当通过一个对象初始化另一个对象时,

	如 \uline{{\tt Test a(10);}}\uline{{\tt Test b(a);}}时:

	假设{\tt Test}中有资源拖管
		
	只记录资源{\tt Data}的指针, 而非记录资源全部信息到类对象里面, 
		构造时从堆上用{\tt new}申请内存供资源后面使用, 析构时从堆上释放内存, 回收掉资源, 
		中间过程资源读写操作都通过指针{\tt p}来完成. {\tt C++}对象构造与析构函数的成对调用, 
		也保证了安全性与不发生泄露({\tt RAII})
	\end{leftcolumn}
	\begin{rightcolumn}
\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
class Test1 public:
	Test1(int s):size(s) 
		p = new char[size];
	~Test1()
		if(p)  delete []p; 
			   p = nullptr;
	int size;
	char* p;
\end{lstlisting}	
	\end{rightcolumn}
\end{paracol}

以右侧结构为例: 

\input{tex_include/pic_tex_include/cpp_c++11_lrvalue_0.tex}

\begin{enumerate}
	\item 浅拷贝: 没有真正new内存, 两者共用一块内存地址, 当最后都析构时, 这块内存会被析构两次, 发生crash
	\item 深拷贝: 将指针指向的资源深入复制了一份
	\item 移动语义: 当原对象不再使用, 使用移动语义, 转移资源, 减少拷贝
\end{enumerate}
参考代码见 \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/c++11/copy_0}{\tt cpp\_c11\_copy\_0}
\subsubsection{移动语义}
移动语义: 一个对象的资源在销毁前, 将其转移给其它对象再用起来, 这样能减少资源带来的构造开销, 程序获得更高的效能

移动语义的使用场景就是需要深拷贝原对象的资源, 而原对象不再使用, 就可以使用移动语义, 本质就是在浅拷贝的基础上
	将原对象具有资源的指针置空.

在{\tt C++11}之前, 移动语义使用的问题:
\begin{enumerate}
	\item 使用移动语义需要在构造函数中加额外的参数来选择是否使用移动语义
	\item 因为需要修改类内数据, 无法使用拷贝构造函数({\tt const T\&})
	\item 非{\tt const}引用又无法引用右值, 并且也需要{\tt const}引用来处理{\tt const}对象
\end{enumerate}

{\tt C++11}直接统一, 增加{\tt \&\&}右值引用, 事情变简单, 想要深拷贝的就{\tt T(const T\&)}实现;
	想要移动拷贝的就实现{\tt T(T\&\&)}. 两者都实现时, 一旦传入是个右值, 根据重载机制会优先
	触发移动拷贝构造调用, 使用移动语意, 转移资源, 减少拷贝

{\tt ->}\quad 底层{\tt const}可用于重载而顶层不能, 对于非{\tt const}对象会优先匹配非{\tt const}引用
\subsubsection{万能引用与引用折叠}

对于一个模板
\begin{lstlisting}[xleftmargin=10em,xrightmargin=10em]
template<typename T> T func(T para){}
\end{lstlisting}

\columnratio{0.3}
\begin{paracol}{2}
	\begin{leftcolumn}
		因为引用与引用的对象是没有区别的, 当传入一个引用时, 无法像指针那样分辨出来.
	\end{leftcolumn}
	\begin{rightcolumn}
		\begin{lstlisting}[xleftmargin=2em]
int i = 1; func(i); -- int func<int >(int para){} 
int&r = i; func(r); -- int func<int >(int para){}
int*p =&i; func(p); -- int*func<int*>(int*para){} 
		\end{lstlisting}
	\end{rightcolumn}
	\begin{leftcolumn*}
		所以当需要引用一个新的对象, 或是引用一个引用需要标注参数是一个引用.
	\end{leftcolumn*}
	\begin{rightcolumn}
		\begin{lstlisting}[xleftmargin=2em]
template<typename T> T& func(T& para){}
int i = 1; func(i); -- int& func<int>(int& para){}
int&r = i; func(r); -- int& func<int>(int& para){}
		//T的值仍是int
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}

在引入右值引用{\tt \&\&}后情况出现了区别, 此时对于一个新的模板
\begin{lstlisting}[xleftmargin=10em,xrightmargin=10em]
template<typename T> T&& func(T&& para){}
\end{lstlisting}

它表明参数是一个引用, 但未必是右引用, 因为{\tt C++}的引用折叠机制
\begin{itemize}
	\item {\tt T\&  \&} 折叠为{tt T\&}
	\item {\tt T\&\& \&} 折叠为{\tt T\&}
	\item {\tt T\&  \&\&} 折叠为{\tt T\&}
	\item {\tt T\&\& \&\&} 折叠为{\tt T\&\&}
\end{itemize}

因此对于传入值为左值或右值会进行如下推导
\begin{lstlisting}[xleftmargin=4em,xrightmargin=2em]
int i = 1; func(i); -- int& func<int&>(int& para){}
		   func(1); -- int&&func<int >(int&&para){}
\end{lstlisting}

当传入为左值{\tt T=int\&}, 根据引用折叠机制{\tt int\& \&\&=int\&}; 当传入为右值{\tt T=int}
.(万能引用处理右值时, {\tt T}为{\tt int}而不是{\tt T\&\&})

万能引用可以接受左值和右值, 但具有如下规则:
\begin{enumerate}
	\item 万能引用的{\tt T}不能被再修饰, 不能被{\tt cv}修饰限定, 否则转为普通右值引用
	\item 在模板类中的模板函数使用万能引用, 只能接受模板函数的模板参数 
			不接受模板类的模板参数, 否则转为普通右值引用
\end{enumerate}
\subsubsection{\tt{move}与\tt{forward}}

引用移除:
\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
template <class _Tp> struct remove_reference        {typedef _Tp type;};
template <class _Tp> struct remove_reference<_Tp& > {typedef _Tp type;};
template <class _Tp> struct remove_reference<_Tp&&> {typedef _Tp type;};
\end{lstlisting}
将类型转化为{\tt remove\_reference::type}时, 根据原类型自动选择合适的版本并得到去掉引用后的类型. 一般是在模板
	中传递模板参数时可以将模板参数转化成无引用类型


由于移动语义只接受右值, 对于一般对象需要将其转化为右值.

\begin{lstlisting}[title=move,xleftmargin=2em,xrightmargin=2em]
	//原型
	template <class _Tp>
	typename remove_reference<_Tp>::type&&
	move(_Tp&& __t) noexcept{
		return static_cast<typename remove_reference<_Tp>::type&&>(__t);
	}
	//传入为左值:
	int i = 1; int&& r = move(i);
	//函数原型
	typename remove_reference<int&>::type&&
	move(int& t) noexcept{
		return static_cast<typename remove_reference<int&>::type&&>(t);
	}
	
	//相当于
	int&& move(int& t) noexcept{return static_cast<int&&>(t);}
	
	1.万能引用模板推导T=int&, 原&&被引用折叠
	2.引用移除接收到模板参数T=int&, 并返回去除引用后的结果即int
	--步骤2的必要性在于将原模板参数引用去除后在添加&&才能得到右值引用类型, 原类型带有左引用时会导致添加的右引用被折叠
	3.返回值是右值的原因是将其强转为右值引用的这个表达式本身是一种值的表达, 一种临时变量, 而不是右值引用类型是右值, 如常见左值例3.
	---
	//传入为右值:
	int&& r = move(1);
	//函数原型
	typename remove_reference<int >::type&&
	move(int&& t) noexcept{
		return static_cast<typename remove_reference<int >::type&&>(t);
	}
	//相当于
	int&& move(int&&t) noexcept{return static_cast<int&&>(t);}

\end{lstlisting}

如上述所言, 当一个右值被右值引用后, 引用本身就成了左值, 这意味着无法将其按照右值进行继续传播.

{\tt forward:} 函数传进来是左引用, 函数体内也保持左引用, 传进来是右引用, 函数体内也保持右引用, 称为完美转发

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em,title={\tt forward}]
	//处理左值作为左引用或者右引用
	template <class _Tp>
	_Tp&&
	forward(typename remove_reference<_Tp>::type& __t) noexcept{
		return static_cast<_Tp&&>(__t);
	}
	//处理右值作为右引用
	template <class _Tp>
	_Tp&&
	forward(typename remove_reference<_Tp>::type&& __t) noexcept{
		static_assert(!is_lvalue_reference<_Tp>::value,
					"can not forward an rvalue as an lvalue");
		return static_cast<_Tp&&>(__t);
	}
	//底层都是static_cast<T&&>(t)
	//需要显示传递模板参数
	//由该函数易知, 传入的模板参数类型决定了传出的类型

	//函数参数使用remove的目的是
	//不管传入的模板参数是什么, 保证左右值会进入对应的版本
	//以检测不经意间指定了错误的模板参数, 如下面将要介绍的传递了左引用模板参数而函数参数是一个右值
\end{lstlisting}

\begin{lstlisting}[title=具体场景]
auto&& n = func(1);

1.				  |	2.						  | 3.
template<class T> |	template<class T>		  |	template<class T>
T&& func(T&& t){  |	T&& func(T&& t){		  |	T&& func(T&& t){
	return t;	  |		return forward<T>(t); |		return static_cast<T&&>(t);
}//error		  |	}						  |	}/*
			
1.   T=int, 返回类型为int&&, 而t是左值.  
2.3. T=int, return forward<int>(t) == return static_cast<int&&>(t)
4.   由上可知, forward<T>跟static_cast<T&&>的作用是一样的
	 原类型是左引用返回左引用, 原类型右引用返回右引用, 完美转发了对象
	 保持原来的左右引用关系并向下层次转化, 不再因右引用表达式是左值从而变掉
	 当传入左值时, T=int&, 2.3. ==
	 	int& func(int& t){ return forward/static_cast<int&>(t); }
\end{lstlisting}

大部分情况下, {\tt static\_cast<T\&\&>(t)}等同{\tt forward<T>(t)}

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em,title=特殊情况]
	template<class A, class B>
	A&& StaticCastFun(A&& a, B&& b) {
		return static_cast<A&&>(b);
	}//warning
	template<class A, class B>
	A&& ForwardCastFun(A&& a, B&& b) {
		return forward<A>(b);
	}//error

	struct TypeB{};
	struct TypeA{
		TypeA() {}
		TypeA(const TypeA&) {}
		~TypeA() {}
		TypeA(const TypeB&) {}
	};
	---
	int main(){
		TypeA ta1;
		TypeB tb1;
		[&](const TypeA a, const TypeB b){
			StaticCastFun(a, b);
			ForwardCastFun(a, b);
		}(ta1,tb1);
		return 0;
	}
	当传入参数与模板参数不是同一类别时, 且存在TypeB到TypeA的转换
	则会在forward<A>(b)时将TypeB b通过TypeA提供的构造函数生成一个临时的TypeA变量并传入forward中
	这个临时变量为右值, 因此会触发forward右值版本, 而A为const TypeA&
	会返回对右值的左引用, 因此forward分开两个版本并在右值处理中判断T是否为左引用. 除此之外与static_cast<T&&>无差别

\end{lstlisting}
测试程序见: \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/c++11/lrvalue_0}{\tt cpp\_c11\_lrvalue\_0}
\subsection{<===>\color{purple}{\tt using}}
\subsubsection{作用域导入}
把目标的访问权限复制到{\tt using}所在的当前作用域, 
	使得目标 视为等同于在当前作用域定义

使用{\tt using}导入命名空间, 即 使一个命名空间中的所有名字都在该作用域中可见
\begin{lstlisting}[xleftmargin=5em,xrightmargin=5em]
	using namespace std; // 导入整个命名空间到当前作用域
	using std::cout;     // 只导入某个变量到当前作用域 
\end{lstlisting}


\begin{lstlisting}[title=在派生类中引用基类成员]
class A{
public:		void func();
protected:	int val;
private:	int pval;
};

class B:private A{   //尽管派生类B对基类A是私有继承, 但通过using声明,
public:			     //派生类的对象就可以访问基类的
					 //proteced成员变量和public成员函数
	using A::func;   //using的声明在public中, 视为在B的public中声明基类成员
	using A::val ;   //简单来说, 就是将原本继承后的private权限改为public
///////////////////////	
//public or private: //error	
//	using A::pval;   //无法对基类private成员进行using
};
\end{lstlisting}
\subsubsection{别名声明}
通过{\tt using}指定别名, 作用等同{\tt typedef}
\subsubsection{别名模板}
{\tt using}能够使用模板, 而{\tt typedef}需要通过结构体包装
\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
	template<typename T> using  vec = vector<T>;
	template<typename T> struct vec {
		typedef vector<T> type;
		or
		using vec = vector<T>;
	};
	vec<int>       v_using
	vec<int>::type v_typedef
\end{lstlisting}
\subsubsection{\tt{typename}}
使用{\tt typedef}加结构体包装的形式实现别名模板存在一个问题, 在使用此别名模板时若没有指定模板参数而是
	传入另一个模板参数, 编译器会无法确认结构体中的这个{\tt type}是不是类型.

{\tt template}内出现的名称如果相依于某个{\tt template}参数, 称之为从属名称. 如果从属名称在{\tt class}内成嵌套状
	{\tt (}即通过从属名称声明的成员{\tt (::type)}在其作用域内与该从属名称也存在依赖关系{\tt )}, 
	称为嵌套从属名称, 即无法确认为类型还是变量的名称

{\tt C++}规定在嵌套从属名称前加{\tt typename}关键字以确定该名称是一个类型.
\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
  template<typename T, class U> 
  void func (T i){
		       _typedef<int>::type a0 = i;  //非从属名称
			   _using  <T  >       a1 = i;  //从属名称
		       _typedef<T  >       a2    ;  //从属名称
	  typename _typedef<T  >::type a3 = i;  //嵌套从属名称
      typename U            ::type a4 = i;  //嵌套从属名称
  }
  //using   可以接受模板   模板绑定在别名上
  //typedef 不可以接受模板 模板绑定在结构体上
  //		在结构体内再声明与模板参数相同的类型成员, 形成了嵌套
  //	    结构体_typedef可能在某个特化的情况下存在成员type不为类型的情况
\end{lstlisting}

特例: 请使用关键字{\tt typename}标识嵌套从属名称, 但不能在基类列{\tt (base class lists)}和
	成员初值列{\tt (member initialization list)}中用{\tt typename}修饰基类{\tt (base class)}, 
	这是确定的一个类型.

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
	template<typename T>
	class C{
	public:
		C(){}
		C(T x):val(x){}
		T val;
	};
	template<typename T>
	struct Base{
		typedef C<T> type;
	};

	template<typename T>
	class D:public Base<T>::type{
	public:
		D(int x):Base<T>::type(x){
			typename Base<T>::type tmpC;
		}
	};
\end{lstlisting}

测试程序见: \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/c++11/using_0}{\tt cpp\_c11\_using\_0}
\subsection{<===>\color{purple}{范围循环}}
在{\tt C++11}中, 凡是支持{\tt begin, end}方法的对象都可以使用范围循环, 本质上是等于迭代器遍历, 
	只不过细节被隐藏使得看上去更简洁.
\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
	vector<int>v;      | = for(auto it = begin(v); it != end(v); ++it)
	for(auto n:v) n++; |		auto n = *it, n++;
		
	vector<int>v;      | = for(auto it = begin(v); it != end(v); ++it)
	for(auto&n:v) n++; |		++*it;//(*it)++;
\end{lstlisting}
\subsubsection{\tt{begin}和\tt{end}}
{\tt begin}和{\tt end}方法对内置数组类型进行了重载, 对其它对象则由对象自身实现相关的迭代器方案, 常见的标准库容器{\tt string, vector}都
	支持{\tt .begin().end()}方法.

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em,title=部分impl]
	template <class Tp, size_t Np>   	template <class Tp, size_t Np> 
	Tp* begin(Tp (&array)[Np]){			Tp* end(Tp (&array)[Np]){
		return array;						return array + Np;
	}									}
    -----------------------------------------------------------------
	template <class Cp>					template <class Cp>
	auto begin(Cp& c) 					auto end(Cp& c) 
	-> decltype(c.begin()){				-> decltype(c.end()){
		return c.begin();					return c.end();
	}									}
\end{lstlisting}
\subsubsection{数组指针}
数组类型与指针很相似, 在很多情况下会退化成一个指针, 失去一部分信息, 无法再使用{\tt begin}和{\tt end}获得头尾指针

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
	int a[]={1,2,3};
	int* p = a;   //指针, 指向a[0].
	int(*p)[3]=&a;//数组指针, 相当于一个二级指针, p指向a.
	int(&r)[3]=a; //数组引用, 跟数组没有区别, 仍保留数组大小信息.

	void f(int a[]);   //数组仍会退化成一个指针 = void f(int* a);
	void f(int(&a)[N]);//不会退化
	void f2(auto& a);  //相当于 int(&a)[N]
	void f2(auto a);   //相当于 int* a

	f(a); //会出现二义性错误, 数组a能同时匹配数组类型和指针类型
	f(p); //只会匹配第一个
\end{lstlisting}

对于一个二维数组, 若想使用范围循环, 在外层循环需要使用引用才能使原本该得到的一维数组不退化成指针, 否则在内层循环中无法对指针进行遍历.

\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
	int a[3][3]={1,2,3,4,5,6,7,8,9};
	//for(int(&c)[3]:a)
	//外层循环得到三个一维数组的引用
	for(auto&c:a){
		for(int i:c){
			cout<<i;
		}
	}
	//for(int*c :a)
	//外层循环得到三个一维数组退化后的指针
	//即指向三个一维数组首元素地址的指针
	for(auto c:a){
		for(int i=0;i<3;++i){
			cout<<c[i];
		}
	}
	auto ftest3_p = [](int p[][3]){
		        //= [](int(*p)[3]) 两种写法相同
		for(int i=0;i<3;++i){
			for(int j=0;j<3;++j){
				//(*(p+i))解引用得到一级指针,指向含有三个元素的数组头
				cout<<(*(p+i))[j];
			}
		}
	};
\end{lstlisting}

参考代码见: \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/c++11/range_0}{\tt cpp\_c11\_range\_0}
\subsection{\color{purple}{强制类型转换}}
{\tt C++}引入新的强制类型转换机制, 主要是为了克服{\tt C}语言强制类型转换没有从形式上体现转换功能和风险不同的问题.

{\tt C}语言的类型转换, 编译器会在下面这些{\tt C++}的转换方法去逐一评估, 直到挑选到合适的. 

如果想清晰确认每一步转换是怎么进行的, 使用{\tt C++}式转换, 对于简单的, 嫌麻烦可由编译器代劳使用{\tt C}式转换.

通过对不同形式的转换进行分类命名可以更清晰分辨程序在转换过程中的具体形式, 使得出现问题时更容易找到可能与之相关的那一类
	转换方法. 
\subsubsection{\tt{static\_cast}}
\columnratio{0.4}
\begin{paracol}{2}
	\begin{leftcolumn}
		低风险转换方式, 不能处理具有底层{\tt const}属性的类型.

		常用于基本内置类型的转换, {\tt void*}指针与其它类型指针的转换, 基类与派生类指针的转换.
	\end{leftcolumn}	
	\begin{rightcolumn}
		\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
void fstatic(){
	double a = 2.2;
	int    b = static_cast<int>(a);

	void* p  = &b;
	int*  ip = static_cast<int*>(p);
}
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}
\subsubsection{\tt{const\_cast}}
\columnratio{0.4}
\begin{paracol}{2}
	\begin{leftcolumn}
		只能用于删除运算对象的底层{\tt const}, 也只有这个函数可以修改对象的底层{\tt const}属性.

		即将一个指向常量的指针转换成普通指针, 获得修改指向对象的权限, 此方法只适用于指向对象是非{\tt const}对象, 
			若指向对象是{\tt const}则行为未定义.
	\end{leftcolumn}	
	\begin{rightcolumn}
		\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
void fconst(){
		  int  n  = 1;
	const int* cp = &n;
	//(*cp)++; error
	      int* p  = const_cast
		  			<int*>(cp);
	(*p)++;

	const int  cn  = 1;
	const int* cp2 = &cn;
		  int* p2  = const_cast
		  			 <int*>(cp2);
	(*p2)++;
	//未定义行为, 本环境未改变cn
}
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}
\subsubsection{\tt{reinterpret\_cast}}
\columnratio{0.4}
\begin{paracol}{2}
	\begin{leftcolumn}
		为运算对象的位模式提供底层重新解释, 用于进行各种不同类型的指针之间、不同类型的引用之间的转换, 
			执行的过程是逐个比特复制的操作.

		自由程度高, 可以将{\tt int*}指针转成{\tt string*}, 至于之后引发的错误...

		对于基类指针与派生类指针的转换不会进行地址的偏移. 
	\end{leftcolumn}	
	\begin{rightcolumn}
		\begin{lstlisting}[xleftmargin=2em,xrightmargin=2em]
void freinterpret(){
	int     a  = 1;
	int*    p  = &a;
	float*  dp = reinterpret_cast
				 <float*>(p);
	//(*dp)=1.4013e-45
	//float和int都是32位但是编码格式不同
	//比特层面上相同, 不同的解释方式
	//得到不同的结果
}
		\end{lstlisting}
	\end{rightcolumn}
\end{paracol}
\subsubsection{\tt{dynamic\_cast}}
TODO:dc

测试程序见: \href{https://github.com/wenqingqian/Obtuse/tree/main/test/cpp/c++11/cast_0}{\tt cpp\_c11\_cast\_0}
\subsection{\color{purple}{智能指针}}
\subsubsection{\color{purple}{\tt RAII}}

{\tt resource acquisition is initialization}

资源获取即变量初始化, 与之对应的便是变量析构即资源释放. 即将需要手动释放的堆资源转换成自动析构的栈对象.

{\tt RAII}要求, 资源的有效期与持有资源的对象的生命期严格绑定, 即由对象的构造函数完成资源的分配(获取), 
同时由对象的析构函数, 完成资源的释放. 在这种要求下, 只要对象能正确地析构, 就不会出现资源泄露问题.

\begin{itemize}
	\item 当函数有多个返回点，或者因异常等原因意外退出函数时，栈上对象会正常的被析构，同时将资源安全释放掉。
			如果不用{\tt RAII}，不仅可能忘记在某个返回点写销毁代码，而且在程序异常时无法保证资源自动释放.
\end{itemize}
